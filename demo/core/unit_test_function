TEST selectedDishes

the code to be tested:

public static ArrayList<Dish> selectDishes(ArrayList<Dish> uncookedDishes, LocalTime cookTime){
        ArrayList<Dish> selectedDishes = new ArrayList<>();
        for(Dish d: uncookedDishes){
            //dish is ordered before the cook is available
            if(d.isNOTEarlierThan(cookTime)) {
                if(selectedDishes.size()==0){
                    selectedDishes.add(d);
                }else if(d.sameDish(selectedDishes.get(0))
                        && selectedDishes.size()<=MAXIMUM){ //pick same dish, let them be cooked at once
                    selectedDishes.add(d);
                }else{
                    break;
                }
            }
        }
        return selectedDishes;
    }

test code

public static void testSelectedDishes(ArrayList<Order> orders){
        ArrayList<Dish> uncookedDishes = new ArrayList<>();
        orders.forEach(o -> uncookedDishes.addAll(o.getDishes()));

        Collections.sort(uncookedDishes);//refer to compareTo in Dish.java
        uncookedDishes.remove(0);
        uncookedDishes.remove(0);

        selectDishes(uncookedDishes,LocalTime.parse("11:02", DateTimeFormatter.ofPattern("HH:mm"))).forEach(d -> System.out.println(d+" "+d.getOrderedTime()));
    }

==============================================


TEST earliestDishes

the code before testing

public static ArrayList<Dish> earliestDishes_bug(ArrayList<Dish> uncookedDishes){
        ArrayList<Dish> earliestDishes = new ArrayList<>();

        Collections.sort(uncookedDishes, Dish.getTimeComparator());
        earliestDishes.add( uncookedDishes.get(0));

        for(Dish d: uncookedDishes){
            if(d.isOrderedSameTimeWith(earliestDishes.get(0))
                    && d.sameDish(earliestDishes.get(0))
                    && earliestDishes.size()<=MAXIMUM
            ){
                earliestDishes.add(d);
            }else{
                break;
            }
        }
//        earliestDishes.add(earliestDish);
        Collections.sort(uncookedDishes); //recover the order of uncookedDishes
        return earliestDishes;
    }

the test code

    public static void testEarliestDishes(ArrayList<Order> orders){
        ArrayList<Dish> uncookedDishes = new ArrayList<>();
        orders.forEach(o -> uncookedDishes.addAll(o.getDishes()));
        ArrayList<Dish> earliestDishes = earliestDishes(uncookedDishes);
        for(Dish d: earliestDishes){
            System.out.println(d.getOrderedTime()+" "+d);
        }
    }

found the bug (the code after testing)


    public static void testEarliestDishes(ArrayList<Order> orders){
        ArrayList<Dish> uncookedDishes = new ArrayList<>();
        orders.forEach(o -> uncookedDishes.addAll(o.getDishes()));
        ArrayList<Dish> earliestDishes = earliestDishes(uncookedDishes);
        for(Dish d: earliestDishes){
            System.out.println(d.getOrderedTime()+" "+d);
        }
    }

================================

TEST dish getTimeComparator

(in dish.java)

public static Comparator<Dish> getTimeComparator() {
        return Comparator.comparing(Dish::getOrderedTime);
    }

test code

    public static void testDishesTimeComparator(ArrayList<Order> orders){
        ArrayList<Dish> uncookedDishes = new ArrayList<>();
        orders.forEach(o -> uncookedDishes.addAll(o.getDishes()));
//        selectDishes(uncookedDishes,LocalTime.parse("11:02", DateTimeFormatter.ofPattern("HH:mm"))).forEach(d -> System.out.println(d+" "+d.getOrderedTime()));
        Collections.sort(uncookedDishes, Dish.getTimeComparator());
        for(Dish d: uncookedDishes){
            System.out.println(d.getOrderedTime()+" "+d);
        }
    }

================================